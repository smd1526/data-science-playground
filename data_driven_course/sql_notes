Use BETWEEN for range queries:
SELECT radius FROM Star
WHERE radius BETWEEN 1 AND 2;

Use COUNT to only return the number of rows in the table requested.
Example:
SELECT COUNT(*) FROM Planet;

Other aggregate functions:
MIN, MAX, SUM, AVG, STDDEV

Example:
SELECT MIN(radius), MAX(radius), AVG(radius) FROM Planet;

Use ORDER BY for sort order. Example:
SELECT koi_name, radius FROM Planet
ORDER BY radius DESC
LIMIT 5;


GROUP BY arranges identical data in groups on which we can perform aggregate functions.
Example:
SELECT radius, COUNT(koi_name)
FROM Planet
GROUP BY radius;
-> returns a table which is grouped by the planet radii and contains the radii and the number of koi_names belonging to each radius.

In order to use aggregate functions in our conditions, we require the HAVING statement instead of WHERE, which gets called after the GROUP BY clause. Example:
SELECT radius, COUNT(koi_name)
FROM Planet
GROUP BY radius
HAVING COUNT(koi_name) > 1;

Example:
SELECT kepler_id, COUNT(koi_name)
FROM Planet 
GROUP BY kepler_id
HAVING COUNT(koi_name) > 1
ORDER BY COUNT(koi_name) desc;

There are several ways to join data from multiple tables in SQL, the simplest one is called an equi-join. An equi-join usually tests for equality on attributes shared across tables. The condition in the WHERE clause is also called a join condition, it specifies how the data is to be joined. By taking this condition out, we've transformed our equi-join into a cross- or cartesian-join.

JOIN ... USING:
Specifying a field of attribute to test for equality

JOIN ... ON:
Specifying a condition

Inner joins: data is combined only when the specified condition is true.

Outer joins: table rows can be combined even if there is no match found to fulfill the join condition. We distinguish between three types of outer joins:


<table1> LEFT OUTER JOIN <table2>
Here all rows from <table1> are kept and missing matches from <table2> are replaced with NULL values.

<table1> RIGHT OUTER JOIN <table2>
All rows from <table2> are kept and missing matches from <table1> are replaced with NULL values.

<table1> FULL OUTER JOIN <table2>
All rows from both tables are kept.


We distinguish between two types of subqueries:
Co-related: the subquery is executed for each element of the outer query.
Non-co-related: the subquery is executed only once.

Examples:

SELECT s.kepler_id
FROM Star s
WHERE EXISTS (
  SELECT * FROM Planet p
  WHERE s.kepler_id = p.kepler_id
    AND p.radius < 1
);

This is a co-related subquery. We select each row in Star where the corresponding kepler_id in Planet is a planet with radius smaller than 1. We may have to query the Planet table for each row in Star and check if the result is not empty using EXISTS.

Non-co-related query:

SELECT s.kepler_id
FROM Star s
WHERE s.kepler_id IN (
  SELECT p.kepler_id FROM Planet p
  WHERE p.radius < 1
);

Here we generate a table with the kepler_ids of all planets with a radius smaller than one, and then we check for each star if its kepler_id is contained in the returned Planet table. We query the Planet table only once.


CREATE TABLE <tablename> (
  <attribute1>  <type1>(size1) <constraint1>,
  <attribute2>  <type2>(size2) <constraint2>,
  ...
);


Common Data Types:
SMALLINT	Signed two-byte integer
INTEGER		Signed four-byte integer
FLOAT		Eight-byte floating-point number
CHAR(n)		Fixed-length string with n characters
VARCHAR(n)	Variable-length string with maximum n characters

Example:

CREATE TABLE Star (
  kepler_id INTEGER,
  t_eff INTEGER,
  radius FLOAT
);
INSERT INTO Star VALUES
  (10341777, 6302, 0.815);

Constraint Types:
NOT NULL	Value cannot be NULL
UNIQUE		Value must be unique in the table
DEFAULT		Specifies a default if the field is left blank
CHECK		Ensures that the value meets a specific condition
PRIMARY KEY	Combination of NOT NULL and UNIQUE
FOREIGN KEY	Ensures the data matches the specified attribute in another table

Example:
CREATE TABLE Star (
  kepler_id INTEGER PRIMARY KEY,
  t_eff INTEGER CHECK (t_eff > 3000),
  radius FLOAT
);

A foreign key links data shared between two or more tables, thereby enforcing referential integrity. An attribute with a foreign key constraint is linked to an attribute in another table.

It can only be filled with a value that exists in the other table.
Example:

CREATE TABLE Star (
  kepler_id INTEGER PRIMARY KEY
);

CREATE TABLE Planet (
  kepler_id INTEGER REFERENCES Star (kepler_id)
);

INSERT INTO Star VALUES (10341777);
INSERT INTO Planet VALUES (10341777);


ALTER TABLE <tablename>
ADD COLUMN <columnname> <datatype> <modifiers>;

ALTER TABLE <tablename>
DROP COLUMN <columnname>;

Example:
ALTER TABLE Star
ADD COLUMN ra FLOAT,
ADD COLUMN decl FLOAT;

ALTER TABLE <tablename>
ALTER COLUMN <columnname> SET DATA TYPE <newtype>;

ALTER TABLE <tablename>
ADD CONSTRAINT <columnname> <newconstraint>;



Psycopg2:
The data from SQL queries in Psycopg2 is returned in form of Python lists. In the last problem, you requested the full Star and Planet table, which returned a list of n tuples of length m, where m is the number of columns and n is the number of rows in these tables.
